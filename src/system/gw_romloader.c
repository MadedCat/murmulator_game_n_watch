/*

This program permits to load ROM generated by LCD-Game-Shrinker.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.
This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

__author__ = "bzhxx"
__contact__ = "https://github.com/bzhxx"
__license__ = "GPLv3"

*/

//to be removed using arguments get rom pointer and size
//#include "../rom_manager.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "..\util_sd.h"
#include "..\screen_util.h"

#define DUMP_DEBUG

#define LOGO_SMALL_PIX_WIDTH (184)
#define LOGO_SMALL_PIX_HEIGHT (138)

#include "gw_type_defs.h"
#include "gw_system.h"
#include "gw_romloader.h"



#define GW_ROM_SIZE_MAX 0x20000U
uint8_t *GW_ROM;

uint16_t *gw_background_pal = NULL;
uint16_t *gw_background = NULL;
uint8_t *gw_segments = NULL;
uint16_t *gw_segments_x = NULL;
uint16_t *gw_segments_y = NULL;
uint16_t *gw_segments_width = NULL;
uint16_t *gw_segments_height = NULL;
uint32_t *gw_segments_offset = NULL;
uint8_t *gw_program = NULL;
uint8_t *gw_melody = NULL;
uint32_t *gw_keyboard = NULL;


gwromheader_t gw_head;

extern char header_buf[200];	// буфер для чтения заголовка

extern uint8_t game_buff[GAME_RAM_SIZE];

extern void updatePalette(const uint8_t *palette,uint16_t length);

/**************** Background *******************/
/*
	Background extracted and adapted to GW LCD from BackgroundNS.png file
	RGB565 16bits pixel format
*/
// uint16_t gw_background_data[320*240];

/**************** segments *******************/
/*
segments extracted and adapted to GW LCD from .svg file
RGB565 16bits pixel format
the data segments are smaller than the reserved memory
*/

//uint16_t gw_segments_data[320*240];
// uint16_t gw_segments_x[NB_SEGS];
// uint16_t gw_segments_y[NB_SEGS];
// uint16_t gw_segments_width[NB_SEGS];
// uint16_t gw_segments_height[NB_SEGS];
// uint32_t   gw_segments_offset[NB_SEGS];

/**************** program file *******************/
// uint8_t gw_program[4096];

/**************** melody file *******************/
// uint8_t gw_melody[4096];

/*** G&W Buttons to CPU inputs Mapping ***/
/*
S1..S8 x K1..4 keyboard matrix input on SM5xx emulated CPU
BA,B direct input on SM5xx emulated CPU
8 buttons on G&W SM

Buttons to keyboards mapping MSB..LSB defined on 8 bits
LEFT | RIGHT | UP | DOWN |A | GAME | SELECT


keyboard[0] is S1 K4..K1
keyboard[1] is S2 K4..K1
.
keyboard[7] is S2 K4..K1
keyboard[8] is BA (8 bits lsb)
keyboard[9] is B   (8 bits lsb)
*/
// uint32_t gw_keyboard[10];

#define ROM_DATA_LENGTH 0xFFFF
#define ROM_DATA (0x00000)


bool gw_load_section(char *file_name, uint8_t* ptr, uint32_t offset, uint32_t size){
   int res;
	size_t bytesRead;
	UINT bytesToRead;
   file_descr=0;

   file_descr = sd_open_file(&sd_file,file_name,FA_READ);
	#ifdef DUMP_DEBUG
		printf("File Open =%d\n",file_descr);
	#endif
	if (file_descr!=FR_OK){sd_close_file(&sd_file);return false;}

   file_descr = sd_seek_file(&sd_file,offset);
   if (file_descr!=FR_OK){sd_close_file(&sd_file);return false;}

   bytesToRead = size;
   file_descr = sd_read_file(&sd_file,ptr,bytesToRead,&bytesRead);
   if (file_descr!=FR_OK){sd_close_file(&sd_file);return false;}
   if (bytesRead != bytesToRead){sd_close_file(&sd_file);return false;}

   #ifdef DUMP_DEBUG
      printf(" bytesToRead=%d, bytesRead=%d\n",bytesToRead,bytesRead);
   #endif
   return true;
}

void gw_dump_struct(){
   printf("cpu_name:[%s]\n",gw_head.cpu_name);
   printf("rom_signature:[%s]\n",gw_head.rom_signature);


   printf("background_palette:[%d]\n",gw_head.background_palette);
   printf("background_palette_size:[%d]\n",gw_head.background_palette_size);
   printf("background_pixel:[%d]\n",gw_head.background_pixel);
   printf("background_pixel_size:[%d]\n",gw_head.background_pixel_size);
   if (gw_head.flags & FLAG_SEGMENTS_4BITS) printf("SEGMENTS: 4 BITS\n");
   if (gw_head.flags & FLAG_SEGMENTS_2BITS) printf("SEGMENTS: 2 BITS\n");
   if (!(gw_head.flags & FLAG_SEGMENTS_4BITS)&&!(gw_head.flags & FLAG_SEGMENTS_2BITS)) printf("SEGMENTS: 8 BITS\n");
   printf("segments_pixel:[%d]\n",gw_head.segments_pixel);
   printf("segments_pixel_size:[%d]\n",gw_head.segments_pixel_size);
   printf("segments_offset:[%d]\n",gw_head.segments_offset);
   printf("segments_offset_size:[%d]\n",gw_head.segments_offset_size);
   printf("segments_x:[%d]\n",gw_head.segments_x);
   printf("segments_x_size:[%d]\n",gw_head.segments_x_size);
   printf("segments_y:[%d]\n",gw_head.segments_y);
   printf("segments_y_size:[%d]\n",gw_head.segments_y_size);
   printf("segments_height:[%d]\n",gw_head.segments_height);
   printf("segments_height_size:[%d]\n",gw_head.segments_height_size);
   printf("segments_width:[%d]\n",gw_head.segments_width);
   printf("segments_width_size:[%d]\n",gw_head.segments_width_size);
   printf("melody:[%d]\n",gw_head.melody);
   printf("melody_size:[%d]\n",gw_head.melody_size);
   printf("program:[%d]\n",gw_head.program);
   printf("program_size:[%d]\n",gw_head.program_size);
   printf("keyboard:[%d]\n",gw_head.keyboard);
   printf("keyboard_size:[%d]\n",gw_head.keyboard_size);
   uint32_t* kbd = (uint32_t*)&GW_ROM[gw_head.keyboard];
   for(uint8_t i=0;i<gw_head.keyboard_size;i++){
      printf("%08X  ",kbd[i]);
   }
   printf("\n");
   printf("prewiew_palette:[%d]\n",gw_head.prewiew_palette);
   printf("prewiew_palette_size:[%d]\n",gw_head.prewiew_palette_size);
   printf("prewiew_pixel:[%d]\n",gw_head.prewiew_pixel);
   printf("prewiew_pixel_size:[%d]\n",gw_head.prewiew_pixel_size);
}

void gw_assign_ptrs(){

   GW_ROM = (uint8_t *)&game_buff[0];   
   memcpy(&gw_head, (uint8_t*) &GW_ROM[0], sizeof(gw_head));
   //gw_dump_struct();

   if (gw_head.background_pixel_size!=0) {
      printf("Paletted background\n");
      gw_background_pal = (uint16_t *)&GW_ROM[gw_head.background_palette];
      gw_background     = (uint16_t *)&GW_ROM[gw_head.background_pixel];
   }

   gw_segments = (uint8_t *)&GW_ROM[gw_head.segments_pixel];
   gw_segments_x = (uint16_t *)&GW_ROM[gw_head.segments_x];
   gw_segments_y = (uint16_t *)&GW_ROM[gw_head.segments_y];
   gw_segments_width = (uint16_t *)&GW_ROM[gw_head.segments_width];
   gw_segments_height = (uint16_t *)&GW_ROM[gw_head.segments_height];
   gw_segments_offset = (uint32_t *)&GW_ROM[gw_head.segments_offset];

   gw_program = (uint8_t *)&GW_ROM[gw_head.program];

   if (gw_head.melody_size != 0)
      gw_melody = (uint8_t *)&GW_ROM[gw_head.melody];

   gw_keyboard = (uint32_t *)&GW_ROM[gw_head.keyboard];
}

bool gw_romloader_rom2ram(char *file_name){
   
   GW_ROM = (uint8_t *)&game_buff[0];
   
   /* variable used to compare the size to detect error, uncompressed  */
   unsigned int rom_size_src  = ROM_DATA_LENGTH;
   unsigned int rom_size_dest = ROM_DATA_LENGTH;

   int res;
	size_t bytesRead;
	UINT bytesToRead;
   file_descr=0;
   memset(header_buf, 0, sizeof(header_buf));  

	#ifdef DUMP_DEBUG
		printf("Begin read\n");
	#endif
   gw_load_section(file_name, header_buf, 0, ROM_HEADER_SIZE);

   file_descr = sd_open_file(&sd_file,file_name,FA_READ);
	#ifdef DUMP_DEBUG
		printf("File Open =%d\n",file_descr);
	#endif
	if (file_descr!=FR_OK){sd_close_file(&sd_file);return false;}
   rom_size_src=sd_file_size(&sd_file);
   sd_close_file(&sd_file);

	#ifdef DUMP_DEBUG
		printf("Header assign\n");
	#endif
   
   memcpy(&gw_head, header_buf, sizeof(gw_head));
   
   if (memcmp(gw_head.cpu_name, ROM_CPU_SM510, 3) == 0) {
      printf("Not compressed : header OK\n");
   } else {
      printf("Unknow ROM format\n");
      return false;
   }

   /* check size */
   /*Check if the data size matches. based on the last object in the ROM header (keyboard) */
   //rom_size_dest = gw_head.keyboard + gw_head.keyboard_size;
   rom_size_dest = gw_head.prewiew_pixel + gw_head.prewiew_pixel_size;

   printf("CPU_name=%s\n", gw_head.cpu_name);
   printf("signature:%s\n", gw_head.rom_signature);
   
   if (rom_size_src != rom_size_dest){
      printf("ROM ERROR,size=%u,expected=%u\n", rom_size_src, rom_size_dest);
      return false;
   }else{
      printf("ROM size: OK\n");
   }
   
   rom_size_dest = gw_head.keyboard + gw_head.keyboard_size;
   if (rom_size_dest < sizeof(game_buff)){
      if(!gw_load_section(file_name, (uint8_t*) &GW_ROM[0], 0, rom_size_dest)) return false;
   } else {
      return false;
   }

   gw_assign_ptrs();

   return true;
   /* Manage the background */

/*
   // check if there is a uncompressed background inside
   if (gw_head.background_pixel_size!=0) {
      printf("Paletted background\n");

      gw_background_pal = (uint16_t *)&game_buff[0];
      gw_load_section((uint8_t*) gw_background_pal, gw_head.background_palette, gw_head.background_palette_size);
      gw_background = (uint16_t *)&gw_background_pal[gw_head.background_palette_size];
      gw_load_section((uint8_t*) gw_background, gw_head.background_pixel, gw_head.background_pixel_size);
   }


   /* Set up pointers to objects base /
   gw_segments = (uint8_t *)&gw_background[gw_head.background_pixel_size];
   gw_load_section((uint8_t*) gw_segments, gw_head.segments_pixel, gw_head.segments_pixel_size);

   gw_segments_x = (uint16_t *)&gw_segments[gw_head.segments_pixel_size];
   gw_load_section((uint8_t*) gw_segments_x, gw_head.segments_x, gw_head.segments_x_size);
   
   gw_segments_y = (uint16_t *)&gw_segments_x[gw_head.segments_x_size];
   gw_load_section((uint8_t*) gw_segments_y, gw_head.segments_y, gw_head.segments_y_size);

   gw_segments_width = (uint16_t *)&gw_segments_y[gw_head.segments_y_size];
   gw_load_section((uint8_t*) gw_segments_width, gw_head.segments_width, gw_head.segments_width_size);

   gw_segments_height = (uint16_t *)&gw_segments_width[gw_head.segments_width_size];
   gw_load_section((uint8_t*) gw_segments_height, gw_head.segments_height, gw_head.segments_height_size);

   gw_segments_offset = (uint16_t *)&gw_segments_height[gw_head.segments_height_size];
   gw_load_section((uint8_t*) gw_segments_offset, gw_head.segments_offset, gw_head.segments_offset_size);
   
   gw_program = (uint16_t *)&gw_segments_offset[gw_head.segments_offset_size];
   gw_load_section((uint8_t*) gw_program, gw_head.program, gw_head.program_size);

   if ( gw_head.melody_size != 0){

      gw_melody = (uint16_t *)&gw_program[gw_head.program_size];
      gw_load_section((uint8_t*) gw_melody, gw_head.melody, gw_head.melody_size);
   
   }
   gw_keyboard = (uint32_t *)&GW_ROM[ gw_head.keyboard];
   */

   //return true;
}

/* Load a ROM image into memory */
bool gw_romloader(char *file_name){
   printf("gw_romloader\n");

   bool rom_status = gw_romloader_rom2ram(file_name);
   //debug
   if (!rom_status) assert(false);
   return rom_status;
}

bool LoadScreenFromGWNSnapshot(char *file_name){
   int res;
	size_t bytesRead;
	UINT bytesToRead;
   file_descr=0;

   memset(header_buf, 0, sizeof(header_buf));  

   gw_load_section(file_name, header_buf, 0, ROM_HEADER_SIZE);
	
	#ifdef DUMP_DEBUG
		printf("Header assign\n");
	#endif

   memcpy(&gw_head, header_buf, sizeof(gw_head));

   printf("palette:[%d]   palette_size:[%d]\n",gw_head.prewiew_palette,gw_head.prewiew_palette_size);
   printf("pixels:[%d]   pixels_size:[%d]\n",gw_head.prewiew_pixel,gw_head.prewiew_pixel_size);

   uint8_t* palette = &game_buff[0];
   uint8_t* pixels  = &game_buff[PREVIEW_PAL_SIZE];

   gw_load_section(file_name, palette, gw_head.prewiew_palette, gw_head.prewiew_palette_size);
   gw_load_section(file_name, pixels, gw_head.prewiew_pixel, gw_head.prewiew_pixel_size);
	
   draw_rect(PREVIEW_POS_X,PREVIEW_POS_Y,PREVIEW_WIDTH,PREVIEW_HEIGHT,COLOR_BACKGOUND,true);//Фон отображения информации о файле //COLOR_BACKGOUND
   bytesToRead = gw_head.prewiew_palette_size;
   updatePalette(palette,bytesToRead);

   int xPos = PREVIEW_POS_X+((PREVIEW_WIDTH/2)-(LOGO_SMALL_PIX_WIDTH/2));
   int yPos = 51;

   for(uint16_t y=0;y<=LOGO_SMALL_PIX_HEIGHT;y++){
      for(uint16_t x=0;x<LOGO_SMALL_PIX_WIDTH;x++){
         uint8_t pixel = (uint8_t)pixels[(x+(y*LOGO_SMALL_PIX_WIDTH))];
         draw_pixel(xPos+x,yPos+y,pixel);
      }
   }

}


/*
bool gw_romloader_rom2flash()
{
   
   GW_ROM = malloc(GW_ROM_SIZE_MAX);

   /* src pointer to the ROM data in the external flash (raw or LZ4) /
   const uint8_t *src = (uint8_t *)ROM_DATA;

   /* dest pointer to the ROM data in the internal RAM (raw) /
   uint8_t *dest = (uint8_t *)GW_ROM;

   /* variable used to compare the size to detect error, uncompressed  /
   uint32_t rom_size_src  = ROM_DATA_LENGTH;
   uint32_t rom_size_dest = ROM_DATA_LENGTH;

   /* 1st part on FLASH before JPEG /
   uint32_t rom_size_compressed_src  = ROM_DATA_LENGTH;

   /* cleanup destination memory with white color (in case of no background) /
   memset(dest, 0xffff, GW_ROM_SIZE_MAX);

   // printf(">>> %04X \r\n", src[0]);
   /* Check it by testing 3 first characters == SM5 /
   
   if (memcmp(src, ROM_CPU_SM510, 3) == 0)
   {
      printf("Not compressed : header OK\n");

      //memcpy(dest, src, ROM_DATA_LENGTH);
      printf("ROM2RAM done\n");

      rom_size_src = ROM_DATA_LENGTH;

#ifdef GW_ROM_LZ4_SUPPORT

      /* Check if it's compressed /
   }
   else if (memcmp(src, LZ4_MAGIC, 4) == 0)
   {
      printf("ROM LZ4 detected\n");
      rom_size_compressed_src = lz4_get_file_size(src);

      rom_size_src = lz4_uncompress(src, dest);

      if ((memcmp(dest, ROM_CPU_SM510, 3) == 0))
      {
         printf("ROM LZ4 : header OK\n");
      }
      else
      {
         printf("ROM LZ4 : header KO\n");
         return false;
      }
#endif

#ifdef GW_ROM_ZOPFLI_SUPPORT
   }
   else if (memcmp(src, ZLIB_MAGIC,4) == 0)
   {

      /* DEFLATE decompression /
      printf("ROM ZLIB detected.\n");
      memcpy(&rom_size_compressed_src, &src[4], sizeof(rom_size_compressed_src));

      size_t n_decomp_bytes;
      int flags = 0;
      flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;

      n_decomp_bytes = tinfl_decompress_mem_to_mem(dest, GW_ROM_SIZE_MAX, &src[8], rom_size_compressed_src, flags);
      assert(n_decomp_bytes != TINFL_DECOMPRESS_MEM_TO_MEM_FAILED);
      rom_size_src = (uint32_t) n_decomp_bytes;

      if ((memcmp(dest, ROM_CPU_SM510, 3) == 0))
      {
         printf("ROM ZLIB : header OK\n");
      }
      else
      {
         printf("ROM ZLIB : header KO\n");
         return false;
      }
#endif

#ifdef GW_ROM_LZMA_SUPPORT
   }
   else if (memcmp(src, LZMA_MAGIC,4) == 0)
   {

      /* DEFLATE decompression /
      printf("ROM LZMA detected.\n");
      memcpy(&rom_size_compressed_src, &src[4], sizeof(rom_size_compressed_src));

      size_t n_decomp_bytes;
      n_decomp_bytes = lzma_inflate(dest, GW_ROM_SIZE_MAX, &src[8], rom_size_compressed_src);
      rom_size_src = (uint32_t) n_decomp_bytes;

      if ((memcmp(dest, ROM_CPU_SM510, 3) == 0))
      {
         printf("ROM LZMA : header OK\n");
      }
      else
      {
         printf("ROM LZMA : header KO\n");
         return false;
      }

#endif
      /* Something wrong in the ROM detection... /
   }
   else
   {
      printf("Unknow ROM format\n");
      return false;
   }

   /* Read in the ROM header /
   memcpy(&gw_head, dest, sizeof(gw_head));

   /* check size /
   /*Check if the data size matches. based on the last object in the ROM header (keyboard) /
   rom_size_dest = gw_head.keyboard + gw_head.keyboard_size;

   if (rom_size_src != rom_size_dest)
   {
      printf("CPU_name=%s\n", gw_head.cpu_name);
      printf("signature:%s\n", gw_head.rom_signature);
      printf("ROM ERROR,size=%u,expected=%u\n", rom_size_src, rom_size_dest);
      return false;
   }
   else
   {
      printf("ROM size: OK\n");
   }

   /* Manage the background /

   // check if there is a uncompressed background inside
   if (gw_head.background_pixel_size != 0)
   {
      printf("RGB565 background\n");
      gw_background = (uint16_t *)&GW_ROM[gw_head.background_pixel];

      (void)rom_size_compressed_src; // unused
   }
#ifdef GW_JPEG_SUPPORT
   // otherwise we get the background from JPEG file
   else if((rom_size_compressed_src+8) != ROM_DATA_LENGTH)
   {
      printf("JPEG background?\n");

      /* JPEG decoder : from Flash to RAM /
      uint32_t JpegSrc;
      uint32_t FrameDst;

      JpegSrc = (uint32_t)&ROM_DATA[rom_size_compressed_src+8];

      /*set destination RGB image, 32 bits aligned /
      FrameDst = (uint32_t)&GW_ROM[rom_size_src + 4 - (rom_size_src % 4)];

      /* cleanup Frame buffer with black color (in case of background cropped) /
      memset((uint8_t *)FrameDst, 0x0, GW_SCREEN_HEIGHT*GW_SCREEN_WIDTH*2);

      assert(JPEG_DecodeToFrameInit((uint32_t)&JPEG_Buffer,JPEG_BUFFER_SIZE) == 0);

      // get jpeg image size

      //determine center position
      uint32_t xImg=0, yImg=0, wImg=0,hImg=0;
      assert (0 == JPEG_DecodeGetSize(JpegSrc, &wImg, &hImg));

      xImg = ( GW_SCREEN_WIDTH - wImg )/2;
      yImg = ( GW_SCREEN_HEIGHT - hImg )/2;

      // decode background and copy it in the righ place in the frame buffer
      assert( 0 == JPEG_DecodeToFrame(JpegSrc, FrameDst, xImg, yImg, 0xFF));

      assert(JPEG_DecodeDeInit() == 0);

      /* set the address of RGB background  /
      gw_background = (uint16_t *)(FrameDst);
   }
#endif
   /* Set up pointers to objects base /
   gw_segments = (uint8_t *)&GW_ROM[gw_head.segments_pixel];

   gw_segments_x = (uint16_t *)&GW_ROM[gw_head.segments_x];
   gw_segments_y = (uint16_t *)&GW_ROM[gw_head.segments_y];
   gw_segments_width = (uint16_t *)&GW_ROM[gw_head.segments_width];
   gw_segments_height = (uint16_t *)&GW_ROM[gw_head.segments_height];
   gw_segments_offset = (uint32_t *)&GW_ROM[gw_head.segments_offset];

   gw_program = (uint8_t *)&GW_ROM[gw_head.program];

   if (gw_head.melody_size != 0)
      gw_melody = (uint8_t *)&GW_ROM[gw_head.melody];

   gw_keyboard = (uint32_t *)&GW_ROM[gw_head.keyboard];

   return true;
}
*/
